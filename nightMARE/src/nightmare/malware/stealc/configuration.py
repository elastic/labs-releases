# coding: "utf-8"

import base64
import lief
import re

from nightmare.malware.stealc import crypto
from nightmare import utils


KEY_REGEX = re.compile(rb"[0-9]{28}")
URI_TLD_REGEX = r"/\b[\w.-]+\.[a-zA-Z]{2,}\b"


def find_uris(uri_list: list[bytes]):
    """
    This function will take a list of strings and return a list of URI
    strings that match regular expression pattern with a URI containing
    a slash and TLD.
    Example: /de4846fc29f26952.php
    """
    uris = []
    uri_pattern = re.compile(URI_TLD_REGEX)

    for byte_string in uri_list:
        try:
            string = byte_string.decode("utf-8")
        except UnicodeDecodeError:
            continue

        if len(string) > 8:
            matches = re.findall(uri_pattern, string)
            uris.extend(matches)
    return uris


def extract(file: bytes) -> dict:
    """
    This function performs extraction of stealc using bytes as input

    :param file: The actual bytes of file being extracted
    :return: A dictionary of extracted fields with values
    """
    if not (PE := lief.parse(file)):
        raise RuntimeError("Failed to parse PE file")

    if not (rdata := utils.get_section_content(PE, ".rdata")):
        raise RuntimeError(".rdata section not found")

    candidate_list = utils.find_strings(rdata)

    if not (key := find_key(candidate_list)):
        raise RuntimeError("Failed to find key")

    strings = [
        crypto.decrypt_string(base64.b64decode(x.decode()), key)
        for x in filter(utils.is_base64, candidate_list)
    ]

    url = [s.decode("utf-8") for s in filter(utils.is_url, strings)][0]
    uri = find_uris(strings)[0]

    return {
        "c2": url + uri,
        "key": key.decode("utf-8"),
    }


def find_key(candidates: list[bytes]) -> bytes:
    """
    This function retrieves the RC4 key by using a regular expression to match
    on 28 consecutive digits (0-9) from one of the strings passed as input.

    :param candidates: List of byte string candidates to identify rc4 key
    :return: rc4 key
    """
    for string in candidates:
        if key := KEY_REGEX.findall(string):
            return key[0]
    return None
