# coding: "utf-8"

import yara
import enum
import lief
import binascii
import typing

from nightmare import utils
from nightmare import cast

from nightmare.analysis import bits
from nightmare.malware.blister import crypto
from nightmare.analysis.compression.lznt1 import lznt1


CORE_KEY_RULE = yara.compile(
    source="""
    rule core_key_rules {
        strings:
            $rule0_key = {FF FF D6 49 8B D7
                          4C 0F A3 F8 80 EC
                          02 C7 45 48 CD 3A
                          08 08}
            $rule1_key = {48 8D 55 F0 48 83
                          C9 FF FF D6 49 8B
                          D7 C7 45 48 ?? ??
                          ?? ?? ?? 8B ??}
        condition:
            any of them
    }
"""
)

CORE_TAG_RULE = yara.compile(
    source="""
    rule core_tag_rules {
        strings:
            $rule0_tag = {8B 7D 38 B8 ?? ?? 
                          ?? ?? E9 70}
            $rule1_tag = {8B 7D ?? B8 ?? ??
                          ?? ?? EB 0F 41 ??
                          B7 ?? 8B 34 87 ??
                          03 ?? EB ?? }
        condition:
            any of them
    }
"""
)

CONFIG_TAG_RULE = yara.compile(
    source="""
    rule config_tag_rules {
        strings:
            $rule0_key = {48 89 04 24 49 63
                          C4 48 8B 04 24 F9
                          41 80 F8 F3 F5 81
                          38 ?? ?? ?? ?? E9
                          00 00 00 00}
        condition:
            any of them
    }
"""
)


CORE_KEY_YARA_OFFSET = 16
CORE_TAG_YARA_OFFSET = 4
CONFIG_TAG_YARA_OFFSET = 19
MAGIC_TAG_SIZE = 4
CONFIG_SIZE = 0x66B
RABBIT_KEY_OFFSET = 0x63E
RABBIT_IV_OFFSET = 0x636
COMPRESSED_DATA_SIZE = 0x62E
UNCOMPRESSED_DATA_SIZE = 0x632
SLEEP_TIME_OFFSET = 0x0C

class BlisterFlags(enum.Enum):
    DO_PERSISTANCE = 0x1
    OWN_PROCESS_REFLECTIVE_INJECTION_METHOD = 0x2
    OWN_PROCESS_HOLLOWING_METHOD = 0x8
    REMOTE_PROCESS_HOLLOWING_METHOD = 0x10
    EXECUTE_PAYLOAD_EXPORT = 0x20
    EXECUTE_SHELLCODE_METHOD = 0x40
    INJECT_WITH_CMDLINE = 0x80
    USE_SYSCALLS = 0x100
    USE_FRESH_MAPPED_NTDLL = 0x200
    ENABLE_SLEEP_BEFORE_INJECTION = 0x1000
    CUSTOM_SLEEP_TIMER_SET = 0x2000
    ENABLE_PROCESS_INSTRUMENTATION_UNHOOK = 0x80000
    ENABLE_KEYING = 0x100000


class SignatureNotFoundException(Exception):
    pass


class BlisterHelper(object):
    """
    Represents a helper class containing data related to the loader part of Blister.

    Attributes:
        core_key_offset (int): Offset value for core xor key.
        core_tag_offset (int): Offset value for core tag.
        core_key (bytes): Xor key used to decrypt Blister's core.
        core_tag (bytes): Tag magic number to locate Blister's core.
        encrypted_memory_offset (int): Offset value for encrypted memory.
        decrypted_memory (bytes): Decrypted memory data.
    """

    def __init__(
        self,
        core_key_offset: int,
        core_tag_offset: int,
        core_key: bytes,
        core_tag: bytes,
        encrypted_memory_offset: int,
        decrypted_memory: bytes,
    ):
        self.core_key_offset = core_key_offset
        self.core_tag_offset = core_tag_offset
        self.core_key = core_key
        self.core_tag = core_tag
        self.encrypted_memory_offset = encrypted_memory_offset
        self.decrypted_memory = decrypted_memory


class Configuration(object):
    """
    Represents Blister configuration object.

    Attributes:
        flag (int): A set of flags indicating various settings for the Blister.
        domain_hash (int): Hash value associated with the domain for the keying feature.
        payload_export_hash (int): Hash value associated with payload export.
        sleep_time (int): Time in seconds for sleep intervals.
        rabbit_key (bytes): Encryption key for Rabbit algorithm.
        rabbit_iv (bytes): Initialization vector for Rabbit algorithm.
        compressed_data_size (int): Size of compressed payload.
        uncompressed_data_size (int): Size of uncompressed payload.
        blister_payload (bytes): Payload data, optionally prefixed with "MZ" for PE files.

    Note:
        The is_pe attribute is set to True based on the presence of the
        BlisterFlags.EXECUTE_SHELLCODE_METHOD flag in the flag attribute.
    """

    def __init__(
        self,
        flag: int,
        domain_hash: int,
        payload_export_hash: int,
        sleep_time: int,
        rabbit_key: bytes,
        rabbit_iv: bytes,
        compressed_data_size: int,
        uncompressed_data_size: int,
        blister_payload: bytes,
    ):
        self.flag = flag
        self.domain_hash = domain_hash
        self.payload_export_hash = payload_export_hash
        self.sleep_time = (
            sleep_time
            if BlisterFlags.CUSTOM_SLEEP_TIMER_SET.value & self.flag
            else 600000
        )
        self.rabbit_key = rabbit_key
        self.rabbit_iv = rabbit_iv
        self.compressed_data_size = compressed_data_size
        self.uncompressed_data_size = uncompressed_data_size
        self.is_pe = not BlisterFlags.EXECUTE_SHELLCODE_METHOD.value & self.flag
        self.blister_payload = (
            b"MZ" + blister_payload[2:] if self.is_pe else blister_payload
        )

    @property
    def __injection_method(self) -> str:
        if BlisterFlags.OWN_PROCESS_REFLECTIVE_INJECTION_METHOD.value & self.flag:
            return "Reflective injection"
        elif BlisterFlags.EXECUTE_SHELLCODE_METHOD.value & self.flag:
            return "Execute shellcode"
        elif BlisterFlags.OWN_PROCESS_HOLLOWING_METHOD.value & self.flag:
            return "Process hollowing current executable (rundll32.exe in case of a DLL sample)"
        elif BlisterFlags.REMOTE_PROCESS_HOLLOWING_METHOD.value & self.flag:
            return "Process hollowing IE or Werfault"
        else:
            raise RuntimeError("Injection method missing in configuration")

    @property
    def enabled_features(self) -> list[str]:
        return [x.name for x in BlisterFlags if x.value & self.flag]

    def __dict__(self) -> dict[str, typing.Any]:
        data = {
            "Configuration": {
                "flag": hex(self.flag),
                "domain_keying_hash": hex(self.domain_hash),
                "payload_export_hash": hex(self.payload_export_hash),
                "sleep_time": self.sleep_time,
                "rabbit_key": binascii.hexlify(self.rabbit_key).decode(),
                "rabbit_iv": binascii.hexlify(self.rabbit_iv).decode(),
                "compressed_data_size": hex(self.compressed_data_size),
                "uncompressed_data_size": hex(self.uncompressed_data_size),
                "injection_method": self.__injection_method,
                "is_pe": self.is_pe,
                "enabled_features": self.enabled_features,
            }
        }
        return data


def decrypt_core(pe: lief.PE.Binary, data: bytes, rsrc_data: bytes) -> BlisterHelper:
    """
    Decrypts the Blister's core using provided data and returns a BlisterHelper instance.

    :param pe: The PE binary.
    :param data: The PE content.
    :param rsrc_data: Resource data of the PE binary.
    :return: A BlisterHelper instance after decrypting the Blister's core using provided data.

    """
    if (
        core_key_offset := utils.yara_scan(data=data, compiled_rule=CORE_KEY_RULE)
    ) is None or (
        core_tag_offset := utils.yara_scan(data=data, compiled_rule=CORE_TAG_RULE)
    ) is None:
        raise SignatureNotFoundException("")

    core_key = utils.get_data(data, core_key_offset + CORE_KEY_YARA_OFFSET, 4)
    core_tag = utils.get_data(data, core_tag_offset + CORE_TAG_YARA_OFFSET, 4)

    encrypted_memory_offset = rsrc_data.find(core_tag) + 4
    decrypted_memory = bits.xor(rsrc_data[encrypted_memory_offset:], core_key)

    return BlisterHelper(
        core_key_offset,
        core_tag_offset,
        core_key,
        core_tag,
        encrypted_memory_offset,
        decrypted_memory,
    )


def extract_configuration(data: bytes) -> Configuration:
    """
    Extracts configuration data from Blister sample using the provided BlisterHelper instance.

    :param data: bytes of a Blister sample to extract the configuration and payload
    :return: Extracted configuration data from the Blister sample.
    """
    pe = lief.parse(raw=data)
    rsrc_data = utils.get_section_content(pe, ".rsrc")
    blister_helper = decrypt_core(pe, data, rsrc_data)

    if (
        config_tag_offset := utils.yara_scan(
            data=blister_helper.decrypted_memory, compiled_rule=CONFIG_TAG_RULE
        )
    ) is None:
        raise SignatureNotFoundException("")

    config_tag = utils.get_data(
        blister_helper.decrypted_memory,
        config_tag_offset + CONFIG_TAG_YARA_OFFSET,
        MAGIC_TAG_SIZE,
    )

    config_blob_offset = (
        blister_helper.decrypted_memory.rfind(config_tag) + MAGIC_TAG_SIZE
    )

    if config_blob_offset == -1:
        raise SignatureNotFoundException("")

    config_blob = blister_helper.decrypted_memory[config_blob_offset:]

    flag = cast.u32(utils.get_data(config_blob, 0, 4))
    domain_hash = cast.u32(utils.get_data(config_blob, 4, 4))
    payload_export_hash = cast.u32(utils.get_data(config_blob, 8, 4))
    sleep_time = cast.u32(utils.get_data(config_blob, SLEEP_TIME_OFFSET, 4))
    rabbit_key = utils.get_data(config_blob, RABBIT_KEY_OFFSET, 16)
    rabbit_iv = utils.get_data(config_blob, RABBIT_IV_OFFSET, 8)
    compressed_data_size = cast.u32(utils.get_data(config_blob, COMPRESSED_DATA_SIZE, 4))
    uncompressed_data_size = cast.u32(utils.get_data(config_blob, UNCOMPRESSED_DATA_SIZE, 4))

    encrypted_payload = rsrc_data[
        blister_helper.encrypted_memory_offset
        + config_blob_offset
        + CONFIG_SIZE : blister_helper.encrypted_memory_offset
        + config_blob_offset
        + CONFIG_SIZE
        + compressed_data_size
    ]

    cipher = crypto.Rabbit(rabbit_key, rabbit_iv)
    decrypted_payload = cipher.crypt(encrypted_payload)
    blister_payload = lznt1(decrypted_payload)

    return Configuration(
        flag,
        domain_hash,
        payload_export_hash,
        sleep_time,
        rabbit_key,
        rabbit_iv,
        compressed_data_size,
        uncompressed_data_size,
        blister_payload,
    )
