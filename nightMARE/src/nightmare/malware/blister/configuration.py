# coding: "utf-8"
import yara
import enum
import lief

from nightmare.analysis import bits
from nightmare.malware.blister import crypto
from nightmare.analysis.compression.lznt1 import lznt1


CORE_KEY_RULE = yara.compile(
    source="rule core_key_rule: bar {strings: $a = {48 8D 55 F0 48 83 C9 FF FF D6 49 8B D7 C7 45 48 ?? ?? ?? ?? ?? 8B ??} condition: $a}"
)
CORE_TAG_RULE = yara.compile(
    source="rule core_tag_rule: bar {strings: $a = {8B 7D ?? B8 ?? ?? ?? ?? EB 0F 41 ?? B7 ?? 8B 34 87 ?? 03 ?? EB ??} condition: $a}"
)
CONFIG_TAG_RULE = yara.compile(
    source="rule config_tag_rule: bar {strings: $a = {48 89 04 24 49 63 C4 48 8B 04 24 F9 41 80 F8 F3 F5 81 38 19 C1 AA F6 E9 00 00 00 00 0F 84 1F 00 00 00 48 8B 04 24 E9 00 00 00 00} condition: $a}"
)

CORE_KEY_YARA_OFFSET = 16
CORE_TAG_YARA_OFFSET = 4
CONFIG_TAG_YARA_OFFSET = 19
MAGIC_TAG_SIZE = 4


class BlisterFlags(enum.Enum):
    DO_PERSISTANCE = 0x1
    OWN_PROCESS_REFLECTIVE_INJECTION_METHOD = 0x2
    OWN_PROCESS_HOLLOWING_METHOD = 0x8
    REMOTE_PROCESS_HOLLOWING_METHOD = 0x10
    EXECUTE_PAYLOAD_EXPORT = 0x20
    EXECUTE_SHELLCODE_METHOD = 0x40
    INJECT_WITH_CMDLINE = 0x80
    USE_SYSCALLS = 0x100
    USE_FRESH_MAPPED_NTDLL = 0x200
    ENABLE_SLEEP_BEFORE_INJECTION = 0x1000
    CUSTOM_SLEEP_TIMER_SET = 0x2000
    ENABLE_PROCESS_INSTRUMENTATION_UNHOOK = 0x80000
    ENABLE_KEYING = 0x100000


class SignatureNotFoundException(Exception):
    pass


class BlisterHelper(object):
    """
    Represents a helper class containing data related to the loader part of Blister.

    Attributes:
        core_key_offset (int): Offset value for core xor key.
        core_tag_offset (int): Offset value for core tag.
        core_key (bytes): Xor key used to decrypt Blister's core.
        core_tag (bytes): Tag magic number to locate Blister's core.
        encrypted_memory_offset (int): Offset value for encrypted memory.
        decrypted_memory (bytes): Decrypted memory data.
    """

    def __init__(
        self,
        core_key_offset: int,
        core_tag_offset: int,
        core_key: bytes,
        core_tag: bytes,
        encrypted_memory_offset: int,
        decrypted_memory: bytes,
    ):
        self.core_key_offset = core_key_offset
        self.core_tag_offset = core_tag_offset
        self.core_key = core_key
        self.core_tag = core_tag
        self.encrypted_memory_offset = encrypted_memory_offset
        self.decrypted_memory = decrypted_memory


class Configuration(object):
    """
    Represents Blister configuration object.

    Attributes:
        flag (int): A set of flags indicating various settings for the Blister.
        domain_hash (int): Hash value associated with the domain for the keying feature.
        payload_export_hash (int): Hash value associated with payload export.
        sleep_time (int): Time in seconds for sleep intervals.
        rabbit_key (bytes): Encryption key for Rabbit algorithm.
        rabbit_iv (bytes): Initialization vector for Rabbit algorithm.
        compressed_data_size (int): Size of compressed payload.
        uncompressed_data_size (int): Size of uncompressed payload.
        blister_payload (bytes): Payload data, optionally prefixed with "MZ" for PE files.

    Note:
        The is_pe attribute is set to True based on the presence of the
        BlisterFlags.EXECUTE_SHELLCODE_METHOD flag in the flag attribute.
    """

    def __init__(
        self,
        flag: int,
        domain_hash: int,
        payload_export_hash: int,
        sleep_time: int,
        rabbit_key: bytes,
        rabbit_iv: bytes,
        compressed_data_size: int,
        uncompressed_data_size: int,
        blister_payload: bytes,
    ):
        self.flag = flag
        self.domain_hash = domain_hash
        self.payload_export_hash = payload_export_hash
        self.sleep_time = sleep_time
        self.rabbit_key = rabbit_key
        self.rabbit_iv = rabbit_iv
        self.compressed_data_size = compressed_data_size
        self.uncompressed_data_size = uncompressed_data_size
        self.is_pe = not BlisterFlags.EXECUTE_SHELLCODE_METHOD.value & self.flag  # TEST
        self.blister_payload = (
            b"MZ" + blister_payload[2:] if self.is_pe else blister_payload
        )

    @property
    def __injection_method(self) -> str:
        if BlisterFlags.OWN_PROCESS_REFLECTIVE_INJECTION_METHOD.value & self.flag:
            return "Reflective injection"
        elif BlisterFlags.EXECUTE_SHELLCODE_METHOD.value & self.flag:
            return "Execute shellcode"
        elif BlisterFlags.OWN_PROCESS_HOLLOWING_METHOD.value & self.flag:
            return "Process hollowing current executable (rundll32.exe in case of a DLL sample)"
        elif BlisterFlags.REMOTE_PROCESS_HOLLOWING_METHOD.value & self.flag:
            return "Process hollowing IE or Werfault"
        else:
            raise RuntimeError("Injection method missing in configuration")

    @property
    def enabled_features(self) -> list[str]:
        return [x.name for x in BlisterFlags if x.value & self.flag]


def __get_match_offset(yara_match) -> int:  # check
    return yara_match[0].strings[0].instances[0].offset


def __get_data(data: bytes, offset: int, size: int) -> bytes:
    return data[offset : offset + size]


def decrypt_core(pe: lief.PE.Binary, data: bytes, rsrc_data: bytes) -> BlisterHelper:
    """
    Decrypts the Blister's core using provided data and returns a BlisterHelper instance.

    Args:
        pe (lief.PE.Binary): The PE binary.
        data (bytes): The PE content.
        rsrc_data (bytes): Resource data of the PE binary.
    """
    core_key_match = CORE_KEY_RULE.match(data=data)
    core_tag_match = CORE_TAG_RULE.match(data=data)

    if not core_key_match or not core_tag_match:
        raise SignatureNotFoundException("")

    core_key_offset = __get_match_offset(core_key_match)
    core_tag_offset = __get_match_offset(core_tag_match)

    core_key = __get_data(data, core_key_offset + CORE_KEY_YARA_OFFSET, 4)
    core_tag = __get_data(data, core_tag_offset + CORE_TAG_YARA_OFFSET, 4)

    encrypted_memory_offset = rsrc_data.find(core_tag) + 4
    decrypted_memory = bits.xor(rsrc_data[encrypted_memory_offset:], core_key)

    return BlisterHelper(
        core_key_offset,
        core_tag_offset,
        core_key,
        core_tag,
        encrypted_memory_offset,
        decrypted_memory,
    )


def extract_configuration(
    pe: lief.PE.Binary, blister_helper: BlisterHelper, rsrc_data: bytes
) -> Configuration:
    """
    Extracts configuration data from Blister sample using the provided BlisterHelper instance.

    Args:
        pe (lief.PE.Binary): The PE binary.
        blister_helper (BlisterHelper): A BlisterHelper instance containing decryption information.
        rsrc_data (bytes): Resource data of the PE binary.
    """
    config_tag_yara_match = CONFIG_TAG_RULE.match(data=blister_helper.decrypted_memory)

    if not config_tag_yara_match:
        raise SignatureNotFoundException("")

    config_tag_offset = __get_match_offset(config_tag_yara_match)
    config_tag = __get_data(
        blister_helper.decrypted_memory,
        config_tag_offset + CONFIG_TAG_YARA_OFFSET,
        MAGIC_TAG_SIZE,
    )

    config_blob_offset = (
        blister_helper.decrypted_memory.rfind(config_tag) + MAGIC_TAG_SIZE
    )

    if config_blob_offset == -1:
        raise SignatureNotFoundException("")

    config_size = 0x66B

    config_blob = blister_helper.decrypted_memory[config_blob_offset:]

    flag = bits.u32(__get_data(config_blob, 0, 4))
    domain_hash = bits.u32(__get_data(config_blob, 4, 4))
    payload_export_hash = bits.u32(__get_data(config_blob, 8, 4))
    sleep_time = bits.u32(__get_data(config_blob, 0x0C, 4))
    rabbit_key = __get_data(config_blob, 0x63E, 16)
    rabbit_iv = __get_data(config_blob, 0x636, 8)
    compressed_data_size = bits.u32(__get_data(config_blob, 0x62E, 4))
    uncompressed_data_size = bits.u32(__get_data(config_blob, 0x632, 4))

    encrypted_payload = rsrc_data[
        blister_helper.encrypted_memory_offset
        + config_blob_offset
        + config_size : blister_helper.encrypted_memory_offset
        + config_blob_offset
        + config_size
        + compressed_data_size
    ]

    cipher = crypto.Rabbit(rabbit_key, rabbit_iv)
    decrypted_payload = cipher.crypt(encrypted_payload)
    blister_payload = lznt1(decrypted_payload)

    return Configuration(
        flag,
        domain_hash,
        payload_export_hash,
        sleep_time,
        rabbit_key,
        rabbit_iv,
        compressed_data_size,
        uncompressed_data_size,
        blister_payload,
    )
