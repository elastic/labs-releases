# coding: "utf-8"

import re
import binascii

from PIL import Image
from io import BytesIO

from nightmare import utils
from nightmare import cast
from nightmare.analysis import bits
from nightmare.analysis.compression import lznt1

TAG = 0xEA79A5C6
CHUNK_SIZE_OFFSET = -4
TAG_OFFSET = 4
XOR_KEY_OFFSET_IDAT = 8
TOTAL_SIZE_OFFSET = 12
OFFSET_PAYLOAD_SIZE = 0xCA8
OFFSET_STAGE3_SIZE = 0xEEC
STAGE3_CONFIGURATION_SIZE = 0xEE4
OFFSET_STAGE2_SIZE = 8
STAGE2_CONFIGURATION_SIZE = 0x3DD


ENCRYPTED_DATA_OFFSET = 0x10
XOR_KEY_OFFSET_PIXELS = 4
LENGTH_OFFSET = 0x0C


def __get_second_stage_content(decompressed_data) -> bytes:
    return utils.get_data(
        decompressed_data,
        cast.u32(utils.get_data(decompressed_data, OFFSET_STAGE2_SIZE, 4))
        + STAGE2_CONFIGURATION_SIZE,
    )


def __get_payload(temp_content) -> bytes:
    payload_size = cast.u32(utils.get_data(temp_content, OFFSET_PAYLOAD_SIZE, 4))
    return utils.get_data(
        temp_content,
        cast.u32(utils.get_data(temp_content, OFFSET_STAGE3_SIZE, 4))
        + STAGE3_CONFIGURATION_SIZE,
        payload_size,
    )


def __get_idat_occurrence(data) -> list[int]:
    return [m.start() for m in re.finditer(b"IDAT", data)]


def __extract_idat_blob(data, occur) -> bytes | None:
    tag_found = False
    encrypted_data = bytes()
    for i in range(len(occur)):
        tag = cast.u32(utils.get_data(data, occur[i] + TAG_OFFSET, 4))
        if tag == TAG:
            xor_key = utils.get_data(data, occur[i] + XOR_KEY_OFFSET_IDAT, 4)
            total_size = (
                cast.u32(utils.get_data(data, occur[i] + TOTAL_SIZE_OFFSET, 4))
                & 0xFFFFFFF0
            )
            tag_found = True
        if tag_found:
            t = cast.u32(utils.get_data(data, occur[i] + CHUNK_SIZE_OFFSET, 4))
            chunk_size = (
                (((t >> 8) & 0xFF) << 16)
                + (((t >> 16) & 0xFF) << 8)
                + (t << 24)
                + (t >> 24)
            ) & 0xFFFFFFFF
            chunk_size = (
                chunk_size
                if len(encrypted_data) + chunk_size < total_size
                else total_size - len(encrypted_data) + 16
            )
            encrypted_data += utils.get_data(data, occur[i] + 4, chunk_size)

    if not tag_found:
        return None
    decrypted_data = bits.xor(encrypted_data[16:], xor_key)
    return decrypted_data


def __idat_extaction_implementation(data: bytes) -> bytes | None:
    """
    Extracts the configuration from the IDAT chunk of the PNG file.

    :param data: The PNG file data.
    :return: The decrypted configuration or None.
    """
    occur = __get_idat_occurrence(data)
    if not occur:
        return None

    decrypted_data = __extract_idat_blob(data, occur)
    if not decrypted_data:
        return None

    decompressed_data = lznt1.lznt1(decrypted_data + b"\x00" * 0x100)
    return decompressed_data


def __find_tag_offset(processed_data) -> int | None:
    """
    Find the offset of the configuration in the pixels data.

    :param processed_data: The pixels data.
    :return: The offset of the encrypted configuration or None if not found.
    """
    for i in range(0, len(processed_data)):
        if binascii.crc32(
            utils.get_data(processed_data, i + 4, 4 * 3)
        ) & 0xFFFFFFFF == int.from_bytes(processed_data[i : i + 0x4], "little"):
            return i
    return None


def __pixels_extraction_implementation(data: bytes) -> bytes | None:
    """
    Extracts the configuration from the pixels of the PNG file.

    :param data: The PNG file data.
    :return: The decrypted configuration or None.
    """
    image_file = BytesIO()
    image = Image.open(BytesIO(data))
    width, height = image.size
    pixels_data = bytearray(
        [
            component
            for i in range(height)
            for j in range(width)
            for component in image.getpixel((j, i))
        ]
    )

    if not (tag_offset := __find_tag_offset(pixels_data)):
        return None
    start_data = pixels_data[tag_offset:]
    encrypted_data = utils.get_data(start_data, ENCRYPTED_DATA_OFFSET)
    xor_key = utils.get_data(start_data, XOR_KEY_OFFSET_PIXELS, size=4)
    length = int.from_bytes(utils.get_data(start_data, LENGTH_OFFSET, size=4), "little")
    decrypted_data = bits.xor(utils.get_data(encrypted_data, 0, size=length), xor_key)
    image_file.close()
    return decrypted_data


def extract(data: bytes) -> bytes:
    """
    Extracts payload from an encrypted file of ghostpulse.

    :param data: bytes of the encrypted file
    :return: payload bytes
    """
    if not (configuration_blob := __idat_extaction_implementation(data)) and not (
        configuration_blob := __pixels_extraction_implementation(data)
    ):
        raise RuntimeError(
            "Extraction unsuccessful, file does not appear to be GhostPulse file\n"
        )

    tmp_content = __get_second_stage_content(configuration_blob)
    encrypted_payload_content = __get_payload(tmp_content)
    encrypted_payload_xor_key = utils.get_data(
        encrypted_payload_content, 0, size=0x32 * 4
    )
    encrypted_payload_content = utils.get_data(encrypted_payload_content, 0x32 * 4)
    payload_content = bits.xor(encrypted_payload_content, encrypted_payload_xor_key)

    return payload_content