# coding: "utf-8"

import re

from nightmare import utils
from nightmare import cast
from nightmare.analysis import bits
from nightmare.analysis.compression import lznt1

TAG = 0xEA79A5C6
CHUNK_SIZE_OFFSET = -4
TAG_OFFSET = 4
XOR_KEY_OFFSET = 8
TOTAL_SIZE_OFFSET = 12
OFFSET_PAYLOAD_SIZE = 0xCA8
OFFSET_STAGE3_SIZE = 0xEEC
STAGE3_CONFIGURATION_SIZE = 0xEE4
OFFSET_STAGE2_SIZE = 8
STAGE2_CONFIGURATION_SIZE = 0x3DD


def __get_tmp_file_content(decompressed_data) -> bytes:
    return utils.get_data(
        decompressed_data,
        cast.u32(utils.get_data(decompressed_data, OFFSET_STAGE2_SIZE, 4))
        + STAGE2_CONFIGURATION_SIZE,
    )


def __get_payload(temp_content) -> bytes:
    payload_size = cast.u32(utils.get_data(temp_content, OFFSET_PAYLOAD_SIZE, 4))
    return utils.get_data(
        temp_content,
        cast.u32(utils.get_data(temp_content, OFFSET_STAGE3_SIZE, 4))
        + STAGE3_CONFIGURATION_SIZE,
        payload_size,
    )


def __get_idat_occurrence(data) -> list[int]:
    return [m.start() for m in re.finditer(b"IDAT", data)]


def __extract_blob(data, occur) -> bytes:
    tag_found = False
    encrypted_data = bytes()
    for i in range(len(occur)):
        tag = cast.u32(utils.get_data(data, occur[i] + TAG_OFFSET, 4))
        if tag == TAG:
            xor_key = utils.get_data(data, occur[i] + XOR_KEY_OFFSET, 4)
            total_size = (
                cast.u32(utils.get_data(data, occur[i] + TOTAL_SIZE_OFFSET, 4))
                & 0xFFFFFFF0
            )
            tag_found = True
        if tag_found:
            t = cast.u32(utils.get_data(data, occur[i] + CHUNK_SIZE_OFFSET, 4))
            chunk_size = (
                (((t >> 8) & 0xFF) << 16)
                + (((t >> 16) & 0xFF) << 8)
                + (t << 24)
                + (t >> 24)
            ) & 0xFFFFFFFF
            chunk_size = (
                chunk_size
                if len(encrypted_data) + chunk_size < total_size
                else total_size - len(encrypted_data) + 16
            )
            encrypted_data += utils.get_data(data, occur[i] + 4, chunk_size)

    if not tag_found:
        raise RuntimeError(
            "Extraction unsuccessful, file does not appear to be GhostPulse file\n"
        )
    decrypted_data = bits.xor(encrypted_data[16:], xor_key)
    return decrypted_data


def extract(data: bytes) -> bytes:
    """
    Extracts payload from an encrypted file of ghostpulse.

    :param data: bytes of the encrypted file
    :return: payload bytes
    """
    occur = __get_idat_occurrence(data)
    if not occur:
        raise RuntimeError(
            "Extraction unsuccessful, file does not appear to be GhostPulse file\n"
        )

    decrypted_data = __extract_blob(data, occur)
    decompressed_data = lznt1.lznt1(decrypted_data + b"\x00" * 0x100)  # padding
    tmp_content = __get_tmp_file_content(decompressed_data)
    encrypted_payload_content = __get_payload(tmp_content)
    payload_content = bits.xor(
        encrypted_payload_content[0x32 * 4 :], encrypted_payload_content[0 : 0x32 * 4]
    )

    return payload_content
