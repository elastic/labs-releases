# coding: utf-8


import re
import capstone
import lief
import yara
import typing

from Crypto.Cipher import ARC4
from nightmare import utils


NETWIRE_YARA = """
    rule netwire_configuration_rules {
        strings:
            $rule0_key = {C7 ?? ?? ?? 10 00
                          00 00 C7 ?? ?? ??
                          ?? ?? ?? ?? ?? ??
                          ?? E8 ?? ?? 00 00
                          ?? ?? ?? c7}  
            $rule0_enc = {C7 ?? ?? ?? ?? 00
                          00 00 C7 ?? ?? ??
                          ?? ?? ?? ?? E8 ??
                          ?? 00 00}

            $rule1_key = {53 55 56 57 6A 10
                          8D ?? ?? ?? 68 ??
                          ?? ?? ?? 50 E8 ??
                          ?? 00 00} 
            $rule1_enc = {E8 ?? ?? 00 00 68 
                          ?? 00 00 00 8D ?? 
                          ?? ?? 68 ?? ?? ?? 
                          ?? 50 e8 ?? ?? 00 
                          00}

            $rule2_key = {C7 ?? ?? ?? 10 00 
                          00 00 C7 ?? ?? ?? 
                          ?? ?? ?? ?? 8D ?? 
                          ?? ?? 89 ?? ?? E8 
                          ?? ?? 00 00 C7 ?? 
                          ?? ?? FF} 
            $rule2_enc = {C7 44 24 08 ?? 00 
                          00 00 C7 44 24 04 
                          ?? ?? ?? ?? 8D 44 
                          24 18 89 ?? ?? E8 
                          ?? ?? 00 00}

            $rule3_key = {C7 ?? ?? ?? 10 00 
                          00 00 C7 ?? ?? ?? 
                          ?? ?? ?? ?? 8D ?? 
                          ?? ?? 89 ?? ?? E8 
                          ?? ?? 00 00 C7 ?? 
                          ?? ?? FF} 
            $rule3_enc = {C7 44 24 08 ?? 00 
                          00 00 C7 44 24 04 
                          ?? ?? ?? ?? 8D 44 
                          24 18 89 ?? ?? E8 
                          ?? ?? 00 00}
        condition:
            all of ($rule0_*) or all of ($rule1_*) or all of ($rule2_*) or all of ($rule3_*)
    }
    """

C2_REGEX = b"(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)"
DOMAIN_REGEX = b"(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\\-]*[a-zA-Z0-9])\\.)+([A-Za-z]|[A-Za-z][A-Za-z0-9\\-]*[A-Za-z0-9])"

RC4_KEY_SIZE = 16
NULL_BYTE = b"\x00"


def __parse_and_set_config(config: list) -> dict[str, typing.Any]:
    netwire_config = dict()
    try:
        domain_list = config[0].rstrip(";").split(";")
        netwire_config["c2_list"] = domain_list
        netwire_config["password"] = config[2]
        netwire_config["host_id"] = config[3]
        netwire_config["mutex"] = config[4]
        netwire_config["installation_path"] = config[5]
        netwire_config["run_registry_key_entry"] = config[6]
        netwire_config["active_setup_Key"] = config[7]
        netwire_config["keylogger_logs_directory"] = config[8]
        netwire_config["sleep_in_seconds"] = int(config[11])
    except (IndexError, ValueError):
        raise RuntimeError(
            "Unable to extract the configuration: Enable the parse the configuration"
        )
    return netwire_config


def __decrypt_configuration_field(encrypted_data: bytes, rc4_key: bytes) -> bytes:
    """
    Decrypts a given encrypted configuration field using the provided RC4 key.

    :param encrypted_data: The encrypted configuration field to decrypt.
    :param rc4_key: The RC4 key to use for decryption.

    :return: The decrypted configuration field as a UTF-8 string.
    """
    decrypted_data = ARC4.new(rc4_key).decrypt(encrypted_data)
    if NULL_BYTE in decrypted_data:
        decrypted_data = decrypted_data[: decrypted_data.index(NULL_BYTE)]
    return decrypted_data


def __extract_config(
    size_rva_encrypted: list, pe: typing.Any
) -> tuple[list, bytes, bytes, typing.Optional[re.Match], typing.Optional[re.Match]]:
    config = list()
    _, rc4_va = size_rva_encrypted.pop(0)
    rc4_key = utils.get_pe_data_from_rva(pe, rc4_va, size=RC4_KEY_SIZE)
    c2_size, encrypted_c2_rva = size_rva_encrypted[0]
    c2_data = utils.get_pe_data_from_rva(pe, encrypted_c2_rva, size=c2_size)
    ip_match = re.match(
        C2_REGEX,
        c2_data,
    )
    domain_name_match = re.match(
        DOMAIN_REGEX,
        c2_data,
    )
    return config, rc4_key, ip_match, domain_name_match


def __decrypt_configuration(size_rva_encrypted: list, pe: lief.PE) -> list:
    """
    Decrypts the configuration.

    :param size_rva_encrypted: A list of extracted addresses where the encryption key and encrypted configuration are found.
    :param pe: The PE (Portable Executable) file object.

    :return: Dictionary of  the decrypted configuration.
    """
    config, rc4_key, ip_match, domain_name_match = __extract_config(size_rva_encrypted, pe)

    for encrypted_str_size, encrypted_str_rva in size_rva_encrypted:
        encrypted_data = utils.get_pe_data_from_rva(
            pe, encrypted_str_rva, size=encrypted_str_size
        )
        if encrypted_data == b"":
            continue
        try:
            if ip_match or domain_name_match:
                decrypted_data = encrypted_data
                if NULL_BYTE in decrypted_data:
                    decrypted_data = decrypted_data[: decrypted_data.index(NULL_BYTE)]
                config.append(decrypted_data.decode("utf-8"))
            else:
                decrypted_data = __decrypt_configuration_field(encrypted_data, rc4_key)
                config.append(decrypted_data.decode("utf-8"))
        except UnicodeDecodeError:
            raise RuntimeError(
                "Unable to extract the configuration: Unsuccessful decryption of the configuration"
            )
    return config


def __extract_encryption_addresses(
    disassembler: capstone.Cs, data: bytes, config_decrypt_func_offset: int
) -> list:
    """
    Disassembles using Capstone to find the addresses where the encryption key
    and the encrypted configuration are located.

    :param disassembler: The Capstone disassembler instance.
    :param data: The binary data to disassemble.
    :param config_decrypt_func_offset: The offset to start disassembling from.

    :return: A list of extracted addresses where the encryption key and encrypted configuration are found.
    """
    extracted_values_list = list()
    for _, instruction in enumerate(
        disassembler.disasm(data[config_decrypt_func_offset:], 0)
    ):
        if (
            (
                len(instruction.operands) > 1
                and instruction.operands[1].type == capstone.CS_OP_IMM
            )
            and instruction.mnemonic == "mov"
            and instruction.operands[0].type == capstone.CS_OP_MEM
        ):
            extracted_values_list.append(instruction.operands[1].value.imm)

        if (
            instruction.mnemonic == "push"
            and instruction.operands[0].type == capstone.CS_OP_IMM
        ):
            extracted_values_list.append(instruction.operands[0].value.imm)

        if instruction.group(capstone.CS_GRP_JUMP) or instruction.group(
            capstone.CS_GRP_RET
        ):
            break

    return extracted_values_list


def extract(data: bytes) -> dict[str, typing.Any]:
    config = list()
    pe = lief.parse(raw=data)

    netwire_rules = yara.compile(source=NETWIRE_YARA)

    disassembler = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
    disassembler.detail = True
    if not netwire_rules.match(data=data):
        raise RuntimeError("The sample does not appear to be NetWire")
    config_decrypt_func_offset = utils.yara_scan(data, netwire_rules)
    extracted_values_list = __extract_encryption_addresses(
        disassembler, data, config_decrypt_func_offset
    )

    if len(extracted_values_list) == 0:
        raise RuntimeError(
            "Unable to extract the configuration: Cannot find addresses of encrypted configuration"
        )

    size_rva_encrypted = list()

    for i in range(0, len(extracted_values_list), 2):
        size_rva_encrypted.append(
            (extracted_values_list[i], extracted_values_list[i + 1])
        )

    config = __decrypt_configuration(size_rva_encrypted, pe)

    netwire_config = __parse_and_set_config(config)
    return netwire_config
