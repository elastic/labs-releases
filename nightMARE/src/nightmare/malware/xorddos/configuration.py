# coding: utf-8

import dataclasses
import lief

from smda.common import SmdaFunction
from smda.common import SmdaReport

from nightmare.malware.xorddos import core as xorddos_core
from nightmare.malware.xorddos import crypto as xorddos_crypto
from nightmare.malware.xorddos import strings as xorddos_strings


@dataclasses.dataclass
class Configuration(object):
    """
    Represents a Xorddos configuration object.

    Attributes:
        key (bytes): The key associated with the configuration.
        c2 (List[bytes]): The extracted C2 host values.
        embedded_urls (List[bytes], optional): A list of embedded URLs. Defaults to an
                                               empty list.
    """

    key: bytes
    c2: list[bytes]
    embedded_urls: list[bytes] = dataclasses.field(default_factory=list)


def __get_all_posible_datarefs(report: SmdaReport.SmdaReport) -> list[int]:
    functions = report.getFunctions()
    datarefs = list()
    for function in functions:
        for ins in function.getInstructions():
            for ref in ins.getDataRefs():
                datarefs.append(ref)
    return datarefs


def __parse_configuration_aux(data: list[bytes]) -> tuple[list[bytes], list[bytes]]:
    c2 = list()
    urls = list()

    for x in data:
        if xorddos_strings.contains_only_printable_characters(x):
            if possible_c2 := xorddos_strings.find_c2_list(x):
                c2 += possible_c2
            elif possible_urls := xorddos_strings.find_embedded_urls(x):
                urls += possible_urls

    return c2, urls


def __parse_configuration(
    elf: lief.Binary,
    report: SmdaReport.SmdaReport,
    function: SmdaFunction.SmdaFunction,
    key: bytes,
    aggressive: bool,
) -> tuple[list[bytes], list[bytes]]:
    if not aggressive:
        candidates = xorddos_crypto.find_encrypted_candidates(function)
    else:
        candidates = __get_all_posible_datarefs(report)
    decrypted_data = xorddos_crypto.decrypt_data(elf, candidates, key)

    return __parse_configuration_aux(decrypted_data)


def get_configuration(binary: bytes, aggressive: bool) -> Configuration:
    """
    Retrieves a configuration object based on the provided binary and aggressiveness
    level.

    :param binary: The binary data of the Xorddos ELF file.
    :param aggressive: A flag indicating whether to use aggressive parsing.
    :return: The configuration object extracted from the binary.
    """
    elf, report = xorddos_core.parse_binary(binary)
    key, xor_function = xorddos_core.find_xor_key_and_function(
        elf, report.getFunctions()
    )
    c2, embedded_urls = __parse_configuration(
        elf, report, xor_function, key, aggressive
    )

    return Configuration(key, c2, embedded_urls)
