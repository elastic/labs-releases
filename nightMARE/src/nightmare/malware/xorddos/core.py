# coding: utf-8

import logging
import typing

import lief
from capstone import x86
from smda import Disassembler
from smda import SmdaConfig
from smda.common import SmdaFunction
from smda.common import SmdaInstruction
from smda.common import SmdaReport


def __get_data_refs(instruction: SmdaInstruction.SmdaInstruction):
    detailed = instruction.getDetailed()
    if len(detailed.operands) > 0:
        for i in detailed.operands:
            value = None
            if i.type == x86.X86_OP_IMM:
                value = i.imm
            if i.type == x86.X86_OP_MEM:
                value = i.mem.disp
                if detailed.reg_name(i.mem.base) == "rip":
                    value += detailed.address + detailed.size
            if value is not None and value > 0:
                yield value


def __find_xor_key(
    function: SmdaFunction.SmdaFunction,
) -> int | None:
    for instruction in function.getInstructions():
        if instruction.mnemonic != "movzx":
            continue

        data_refs = list(__get_data_refs(instruction))
        if not data_refs:
            continue

        return data_refs[0]

    return None


def __get_xor_key(elf: lief.Binary, key_address: int) -> bytes:
    return elf.get_content_from_virtual_address(key_address, 16).tobytes()


def find_xor_key_and_function(
    elf: lief.Binary,
    functions: typing.Iterator[SmdaFunction.SmdaFunction],
) -> tuple[bytes, SmdaFunction.SmdaFunction]:
    for function in functions:
        if len(function.outrefs) != 0 or len(function.inrefs) <= 4:  # type: ignore
            continue

        if key_address := __find_xor_key(function):
            return __get_xor_key(elf, key_address), function

    raise RuntimeError("Failed to find xor key and function")


def parse_binary(
    binary: bytes,
) -> tuple[lief.Binary, SmdaReport.SmdaReport]:
    """
    Parses the provided binary and generates an LIEF binary object and an SMDA report.

    :param binary: The binary data to be parsed.
    :return: A tuple containing the LIEF binary object and the SMDA report.
    :raises RuntimeError: If the binary parsing fails.
    """
    elf = lief.parse(binary)
    if not elf:
        raise RuntimeError("Failed to parse binary")

    smda_config = SmdaConfig.SmdaConfig()
    smda_config.LOG_LEVEL = logging.ERROR
    disassembler = Disassembler.Disassembler(smda_config)
    report = disassembler.disassembleBuffer(binary, elf.imagebase)

    return elf, report
