# coding: utf-8

import construct

from nightmare.malware.icedid import crypto

MINIMUM_SIZE = 1024
MAGIC = 0x8B1F
FILENAME_OFFSET = 10


class FakeGzip(object):
    """
    ICEDID FakeGzip parser
    """

    FakeGzipStruct = construct.Struct(
        "flag" / construct.Int8ul,
        "is_dll" / construct.Int8ul,
        "core_size" / construct.Int32ul,
        "stage_2_size" / construct.Int32ul,
        "core_directory" / construct.Array(32, construct.Int8ul),
        "core_filename" / construct.Array(32, construct.Int8ul),
        "stage_2_filename" / construct.Array(32, construct.Int8ul),
        "encrypted_configuration" / construct.Array(604, construct.Int8ul),
        "encrypted_core_and_stage_2"
        / construct.Array(
            construct.this.core_size + construct.this.stage_2_size, construct.Int8ul
        ),
    )

    def __check_data(self, data: bytes) -> None:
        if len(data) < MINIMUM_SIZE:
            raise RuntimeError("Data is too small")

        if MAGIC != int.from_bytes(data[:2], "little"):
            raise RuntimeError("Bad magic")

    def __get_offset_to_payload(self, data: bytes) -> int:
        offset = FILENAME_OFFSET
        while 0 != data[offset]:
            offset += 1
        return offset + 1

    def __repr__(self) -> str:
        output = "is_dll: {}\n".format(self.is_dll)
        output += "core: {}/{} ({} bytes)\n".format(
            self.core_directory, self.core_filename, self.core_size
        )
        output += "stage_2: {} ({} bytes)".format(
            self.stage_2_filename, self.stage_2_size
        )
        return output

    def __init__(self, data: bytes) -> None:
        self.__check_data(data)

        # TODO: Fix check_integrity=False
        encrypted_payload = data[self.__get_offset_to_payload(data) : -4]
        decrypted_payload = crypto.decrypt_0(encrypted_payload, check_integrity=False)
        if not decrypted_payload:
            raise RuntimeError("Failed to decrypt payload")

        self.__fake_gzip = self.FakeGzipStruct.parse(decrypted_payload)

    @property
    def configuration(self) -> bytes:
        return bytes(self.__fake_gzip.encrypted_configuration)

    @property
    def core(self) -> bytes:
        return bytes(
            self.__fake_gzip.encrypted_core_and_stage_2[: self.__fake_gzip.core_size]
        )

    @property
    def core_directory(self) -> str:
        return str(bytes(self.__fake_gzip.core_directory), "utf-8").strip("\x00")

    @property
    def core_filename(self) -> bytes:
        return (
            str(bytes(self.__fake_gzip.core_filename), "utf-8")
            .strip("\x00")
            .strip("\\")
        )

    @property
    def core_size(self) -> int:
        return self.__fake_gzip.core_size

    @property
    def is_dll(self) -> bool:
        return bool(self.__fake_gzip.is_dll)

    @property
    def stage_2(self) -> bytes:
        return bytes(
            self.__fake_gzip.encrypted_core_and_stage_2[self.__fake_gzip.core_size :]
        )

    @property
    def stage_2_filename(self) -> bytes:
        return str(bytes(self.__fake_gzip.stage_2_filename), "utf-8").strip("\x00")

    @property
    def stage_2_size(self) -> int:
        return self.__fake_gzip.stage_2_size
