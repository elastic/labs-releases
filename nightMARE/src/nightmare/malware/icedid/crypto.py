# coding: utf-8

import typing

from nightmare.analysis import bits

KEY_LENGTH = 16
HASH_LENGTH = 4
CRYPTO_DATA_SIZE = 20


def __parse_key(data: bytes) -> list[int]:
    key: list[int] = list()
    for offset in range(0, KEY_LENGTH, 4):
        key.append(int.from_bytes(data[offset : offset + 4], "little"))
    return key


def __parse_integrity_hash(data: bytes, key: int) -> int:
    return int.from_bytes(data, "little") ^ key


def __decrypt_aux(encrypted_data: bytes, key: list[int]) -> bytes:
    decrypted_data = bytearray([0 for _ in range(len(encrypted_data))])

    for i, x in enumerate(encrypted_data):
        index_0 = i & (len(key) - 1)
        index_1 = (i + 1) & (len(key) - 1)
        decrypted_data[i] = (x ^ (key[index_0] + key[index_1])) & 0xFF
        key[index_0] = bits.ror32(key[index_0], key[index_1] & 7) + 1
        key[index_1] = bits.ror32(key[index_1], key[index_0] & 7) + 1

    return bytes(decrypted_data)


def __check_integrity(decrypted_data: bytes, integrity_hash: int) -> bool:
    hash = 0
    for x in decrypted_data:
        hash = bits.rol32(x + hash, 3)
    return hash == integrity_hash


def decrypt_0(encrypted_data: bytes, check_integrity=True) -> typing.Optional[bytes]:
    """
    The function decrypt ICEDID's encrypted data
    :param encrypted_data: ICEDID's encrypted data
    :param check_integrity: Flag to enable/disable data integrity check after decryption
    """

    encrypted_data = bytearray(encrypted_data)

    crypto_data = encrypted_data[len(encrypted_data) - CRYPTO_DATA_SIZE :]
    encrypted_data = encrypted_data[: len(encrypted_data) - CRYPTO_DATA_SIZE]

    key = __parse_key(crypto_data[HASH_LENGTH:])
    integrity_hash = __parse_integrity_hash(crypto_data[:HASH_LENGTH], key[0])
    decrypted_data = __decrypt_aux(encrypted_data, key)

    return (
        decrypted_data
        if (not check_integrity or __check_integrity(decrypted_data, integrity_hash))
        else None
    )


def decrypt_1(encrypted_data: bytes) -> typing.Optional[bytes]:
    """
    The function decrypt ICEDID's encrypted data from forked-variant loader using 64-bit key
    :param encrypted_data: ICEDID's encrypted data
    """

    decrypted_data = bytearray()
    for i in range(len(encrypted_data[:64])):
        decrypted_data.append(encrypted_data[i] ^ encrypted_data[i + 64])

    return bytes(decrypted_data)
