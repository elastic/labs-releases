from __future__ import annotations

import lief
import construct
import ctypes

from nightmare import win32
from nightmare.malware.icedid import core

OFFSET_TO_NAME = 2
SIZEOF_IMAGE_BASE_RELOCATION = 8


def protection_to_lief_section_characteristics(
    protection: int,
) -> lief.PE.SECTION_CHARACTERISTICS:
    match protection:
        case win32.PAGE_READONLY:
            return lief.PE.SECTION_CHARACTERISTICS.MEM_READ
        case win32.PAGE_READWRITE:
            return (
                lief.PE.SECTION_CHARACTERISTICS.MEM_READ
                | lief.PE.SECTION_CHARACTERISTICS.MEM_WRITE
            )
        case win32.PAGE_EXECUTE_READ:
            return (
                lief.PE.SECTION_CHARACTERISTICS.MEM_READ
                | lief.PE.SECTION_CHARACTERISTICS.MEM_EXECUTE
            )
        case win32.PAGE_EXECUTE_READWRITE:
            return (
                lief.PE.SECTION_CHARACTERISTICS.MEM_READ
                | lief.PE.SECTION_CHARACTERISTICS.MEM_WRITE
                | lief.PE.SECTION_CHARACTERISTICS.MEM_EXECUTE
            )


class CustomPE(object):
    """
    ICEDID's custom PE format parser
    """

    CustomPESection = construct.Struct(
        "virtual_address" / construct.Int32ul,
        "virtual_size" / construct.Int32ul,
        "raw_offset" / construct.Int32ul,
        "raw_size" / construct.Int32ul,
        "protection" / construct.Int8ul,
    )

    CustomPEV0 = construct.Struct(
        "imagebase" / construct.Int32ul,
        "field_4" / construct.Int32ul,
        "size" / construct.Int32ul,
        "entrypoint" / construct.Int32ul,
        "import_va" / construct.Int32ul,
        "reloc_va" / construct.Int32ul,
        "reloc_size" / construct.Int32ul,
        "field_1c" / construct.Int32ul,
        "n_sections" / construct.Int32ul,
        "sections" / construct.Array(construct.this.n_sections, CustomPESection),
    )

    CustomPEV1 = construct.Struct(
        "imagebase" / construct.Int64ul,
        "size" / construct.Int32ul,
        "entrypoint" / construct.Int32ul,
        "import_va" / construct.Int32ul,
        "reloc_va" / construct.Int32ul,
        "reloc_size" / construct.Int32ul,
        "n_sections" / construct.Int32ul,
        "sections" / construct.Array(construct.this.n_sections, CustomPESection),
    )

    def __init__(self, data: bytes) -> None:
        self.__content = data

        self.structure = None
        for parser in [CustomPE.CustomPEV0, CustomPE.CustomPEV1]:
            try:
                self.structure = parser.parse(data)
                break
            except Exception:
                continue
        else:
            raise RuntimeError("Failed to parse custom pe")

        self.__is_32 = 0 == 0xFFFFFFFF00000000 & self.structure.imagebase

    def __set_header(self, pe: lief.PE.Binary) -> lief.PE.Binary:
        # Hack to fix lief behavior
        pe.header.sizeof_optional_header = 0xE0 if self.__is_32 else 0xF0
        # !

        pe.optional_header.imagebase = self.structure.imagebase
        pe.optional_header.addressof_entrypoint = self.structure.entrypoint

        pe.data_directories[lief.PE.DATA_DIRECTORY.IMPORT_TABLE].rva = (
            self.structure.import_va
        )

        pe.data_directories[lief.PE.DATA_DIRECTORY.BASE_RELOCATION_TABLE].rva = (
            self.structure.reloc_va
        )

        pe.data_directories[lief.PE.DATA_DIRECTORY.BASE_RELOCATION_TABLE].size = (
            self.structure.reloc_size
        )

        return pe

    def __add_sections(self, pe: lief.PE.Binary) -> lief.PE.Binary:
        for i, custom_section in enumerate(self.structure.sections):
            section = lief.PE.Section(f".mare{i}")
            section.virtual_address = custom_section.virtual_address
            section.virtual_size = custom_section.virtual_size
            section.characteristics = protection_to_lief_section_characteristics(
                custom_section.protection
            )

            section.content = list(
                self.__content[
                    custom_section.raw_offset : custom_section.raw_offset
                    + custom_section.raw_size
                ]
            )

            pe.add_section(section, lief.PE.SECTION_TYPES.DATA)
        return pe

    @property
    def content(self) -> bytes:
        return self.__content

    @property
    def is_32(self) -> bool:
        return self.__is_32

    def to_pe(self) -> lief.PE.Binary:
        """
        The method build a lief PE from the parsed custom PE format
        :return: Reconstructed lief PE
        """
        pe = lief.PE.Binary(
            "icedid",
            lief.PE.PE_TYPE.PE32 if self.__is_32 else lief.PE.PE_TYPE.PE32_PLUS,
        )
        return self.__add_sections(self.__set_header(pe))


class Loader(object):
    """
    ICEDID custom PE loader.
    Will map binary into current process, resolve imports and apply relocations.
    """

    def __init__(self, custom_pe: CustomPE) -> None:
        self.__custom_pe = custom_pe
        self.__base_address = 0

        self.__map()
        self.__resolve_imports()
        self.__apply_relocations()

    def __apply_relocations_aux(self, relocations_address: int) -> None:
        while True:
            relocations = ctypes.cast(
                relocations_address, ctypes.POINTER(win32.IMAGE_BASE_RELOCATION)
            ).contents

            if not relocations.SizeOfBlock:
                break

            for address in range(
                relocations_address + SIZEOF_IMAGE_BASE_RELOCATION,
                relocations_address
                + ((relocations.SizeOfBlock - SIZEOF_IMAGE_BASE_RELOCATION) // 2),
                2,
            ):
                relocation = ctypes.cast(
                    address, ctypes.POINTER(ctypes.c_uint16)
                ).contents.value

                relocation_type = relocation >> 12
                relocation_offset = relocation & 0xFFF

                match relocation_type:
                    case win32.IMAGE_REL_BASED_HIGHLOW:
                        type_ = ctypes.c_uint32
                    case win32.IMAGE_REL_BASED_DIR64:
                        type_ = ctypes.c_uint64
                    case _:
                        continue

                ptr = ctypes.cast(
                    self.__base_address
                    + relocations.VirtualAddress
                    + relocation_offset,
                    ctypes.POINTER(type_),
                )

                ptr.contents = type_(
                    ptr.contents.value
                    - self.__custom_pe.structure.imagebase
                    + self.__base_address
                )

            relocations_address += relocations.SizeOfBlock

    def __apply_relocations(self) -> None:
        assert self.__base_address

        if (
            self.__custom_pe.structure.imagebase == self.__base_address
            or not self.__custom_pe.structure.reloc_va
        ):
            return

        self.__apply_relocations_aux(
            self.__base_address + self.__custom_pe.structure.reloc_va
        )

    def __allocate_image_memory(self) -> None:
        self.__base_address = win32.get_VirtualAlloc()(
            self.__custom_pe.structure.imagebase,
            self.__custom_pe.structure.size,
            win32.MEM_COMMIT | win32.MEM_RESERVE,
            win32.PAGE_EXECUTE_READWRITE,
        )

        if not self.__base_address:
            raise RuntimeError(
                "Failed to allocate image memory. GLE={}".format(
                    win32.get_GetLastError()()
                )
            )

    def __map_sections(self) -> None:
        for section in self.__custom_pe.structure.sections:
            for i in range(section.raw_size):
                self.memory[section.virtual_address + i] = self.__custom_pe.content[
                    section.raw_offset + i
                ]

    def __map(self) -> None:
        self.__allocate_image_memory()
        self.__map_sections()

    def __load_library_and_get_thunks(
        self, import_descriptor: ctypes.POINTER
    ) -> tuple[ctypes.c_void_p, ctypes.POINTER]:
        library_name = ctypes.cast(
            self.__base_address + import_descriptor.Name, ctypes.c_char_p
        )

        library = win32.get_LoadLibraryA()(library_name)
        if not library:
            raise RuntimeError(
                "LoadLibraryA of {} failed, GLE={}".format(
                    library_name, win32.get_GetLastError()()
                )
            )

        thunks = ctypes.cast(
            self.__base_address
            + (
                import_descriptor.FirstThunk
                if import_descriptor.FirstThunk
                else import_descriptor.OriginalFirstThunk
            ),
            (
                ctypes.POINTER(win32.IMAGE_THUNK_DATA32)
                if self.__custom_pe.is_32
                else ctypes.POINTER(win32.IMAGE_THUNK_DATA64)
            ),
        )

        return library, thunks

    def __load_imports(self, library: ctypes.c_void_p, thunks: ctypes.POINTER) -> None:
        i = 0
        while True:
            if not thunks[i].AddressOfData:
                break

            ordinal_bit = 2 ** (31 if self.__custom_pe.is_32 else 63)
            if ordinal_bit & thunks[i].AddressOfData:
                import_name = thunks[i].AddressOfData & (ordinal_bit - 1)
            else:
                import_name = ctypes.cast(
                    self.__base_address + thunks[i].AddressOfData + OFFSET_TO_NAME,
                    ctypes.c_char_p,
                )

            function = win32.get_GetProcAddress()(library, import_name)
            if not function:
                raise RuntimeError(
                    "GetProcAddress of {} Failed. GLE={}".format(
                        import_name, win32.get_GetLastError()()
                    )
                )

            thunks[i].Function = function

            i += 1

    def __resolve_imports_aux(self, import_descriptors: ctypes.POINTER) -> None:
        i = 0
        while True:
            if not import_descriptors[i].Name:
                break

            library, thunks = self.__load_library_and_get_thunks(import_descriptors[i])
            self.__load_imports(library, thunks)

            i += 1

    def __resolve_imports(self) -> None:
        assert self.__base_address

        if not self.__custom_pe.structure.import_va:
            return

        self.__resolve_imports_aux(
            ctypes.cast(
                self.__base_address + self.__custom_pe.structure.import_va,
                ctypes.POINTER(win32.IMAGE_IMPORT_DESCRIPTOR),
            )
        )

    @property
    def base_address(self) -> int:
        return self.__base_address

    @property
    def entrypoint(self) -> int:
        return self.__base_address + self.__custom_pe.structure.entrypoint

    @property
    def EntryPoint(self) -> core.EntryPointFunction:
        return ctypes.cast(self.entrypoint, core.EntryPointFunction)

    @property
    def memory(self) -> ctypes.POINTER[ctypes.c_ubyte]:
        if not self.__base_address:
            RuntimeError("No memory")
        return ctypes.cast(self.__base_address, ctypes.POINTER(ctypes.c_ubyte))
