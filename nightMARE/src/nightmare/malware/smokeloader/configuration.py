# coding: utf-8

import capstone
import yara
import typing

from Crypto.Cipher import ARC4
from nightmare import utils


SMOKELOADER_64_YARA = """
    rule smokeloader_configuration_rules {
        strings:
            $rule0_key = {48 89 5C 24 08 48
                          89 6C 24 10 48 89
                          74 24 18 57 41 56
                          41 57 48 83 EC 40
                          4C 8B FA 48 8B E9
                          E8 ?? ?? ?? ?? 48
                          ?? ?? ?? ?? ?? ??
                          48 8B CD}
        condition:
            all of them
    }
    """

SMOKELOADER_32_YARA = """
    rule smokeloader_configuration_rules {
        strings:
            $rule0_key = {51 53 55 56 57 ?? 
                          ?? ?? ?? 8B E9 E8 
                          ?? ?? ?? ?? BA ?? 
                          ?? ?? ?? 8B CD E8}
        condition:
            all of them
    }
    """

SMOKELOADER_64_RULES = yara.compile(source=SMOKELOADER_64_YARA)
SMOKELOADER_32_RULES = yara.compile(source=SMOKELOADER_32_YARA)

RVA_TO_RAW_OFFSET = 0x400 - 0x1000


def _extract_config(config_addr: int, data: bytes) -> tuple[bytes, bytes]:
    """
    Extracts the encryption key and the encrypted configuration from the binary data.

    :param config_addr: The address where the configuration starts.
    :param data: The binary data containing the configuration.
    :return: A tuple containing the encryption key and the encrypted configuration.
    """
    size_encrypted_c2 = int.from_bytes(
        data[config_addr : config_addr + 1], "little"
    )  # add constants
    rc4_key = data[config_addr + 1 : config_addr + 5]
    encrypted_c2 = data[config_addr + 5 : config_addr + size_encrypted_c2 + 1]
    return rc4_key, encrypted_c2


def _decrypt_configuration(config_addr: int, data: bytes) -> bytes:
    """
    Decrypts the configuration.

    :param size_rva_encrypted: A list of extracted addresses where the encryption key and encrypted configuration are found.
    :param pe: The PE (Portable Executable) file object.

    :return: The decrypted configuration.
    """
    rc4_key, encrypted_c2 = _extract_config(config_addr, data)

    rc4 = ARC4.new(rc4_key)
    try:
        config = rc4.decrypt(encrypted_c2)
    except ValueError:
        raise RuntimeError(
            "Unable to extract the configuration: Unsuccessful decryption of the configuration"
        )
    return config


def _extract_encryption_addresses(
    data: bytes, config_decrypt_func_offset: int, is_64: bool
) -> int | None:
    """
    Disassembles using Capstone to find the addresses where the encryption key
    and the encrypted configuration are located.

    :param data: The binary data to disassemble.
    :param config_decrypt_func_offset: The offset to start disassembling from.
    :param is_64: A boolean indicating whether the binary is 64-bit or not.

    :return: The extracted address where the encryption key and encrypted configuration are found.
    """
    disassembler = (
        capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_64)
        if is_64
        else capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_32)
    )
    disassembler.detail = True
    for _, instruction in enumerate(
        disassembler.disasm(data[config_decrypt_func_offset:], 0)
    ):
        if (
            (
                len(instruction.operands) > 1
                and instruction.operands[1].type
                == (capstone.CS_OP_MEM if is_64 else capstone.CS_OP_IMM)
            )
            and instruction.mnemonic == ("lea" if is_64 else "mov")
            and instruction.reg_name(instruction.operands[0].value.reg)
            == ("rdx" if is_64 else "edx")
        ):
            return (
                (
                    instruction.operands[1].value.mem.disp
                    + instruction.address
                    + instruction.addr_size
                    + config_decrypt_func_offset
                    - 1
                )
                if is_64
                else ((instruction.operands[1].value.imm + RVA_TO_RAW_OFFSET) & 0xFFFF)
            )

        if instruction.group(capstone.CS_GRP_JUMP) or instruction.group(
            capstone.CS_GRP_RET
        ):
            return None


def extract(data: bytes) -> dict[str, typing.Any]:
    """
    Extracts configuration from SmokeLoader.

    :param data: The binary data to extract information from.

    :return: A dictionary containing the extracted configuration.
    """
    if config_decrypt_func_offset := utils.yara_scan(data, SMOKELOADER_64_RULES):
        extracted_addr = _extract_encryption_addresses(
            data, config_decrypt_func_offset, is_64=True
        )
    elif config_decrypt_func_offset := utils.yara_scan(data, SMOKELOADER_32_RULES):
        extracted_addr = _extract_encryption_addresses(
            data, config_decrypt_func_offset, is_64=False
        )
    else:
        raise RuntimeError("The sample does not appear to be SmokeLoader")

    if not extracted_addr:
        raise RuntimeError(
            "Unable to extract the configuration: Cannot find addresses of encrypted configuration"
        )

    decrypted_c2 = _decrypt_configuration(extracted_addr, data)
    return {"c2": decrypted_c2.decode("utf-8")}
