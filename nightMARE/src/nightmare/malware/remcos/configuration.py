# coding: utf-8

from __future__ import annotations

import pathlib
import lief
import typing
import base64

from Crypto.Cipher import ARC4

from nightmare import cast

CONFIGURATION_SEPARATOR = b"\x7c\x1e\x1e\x1f\x7c"

C2_SEPARATOR = b"\x1e"

DIRECTORY_MAPPING = {
    0: "%Temp%",
    1: "<CurrentMalwareDirectory>",
    2: "%SystemDrive%",
    3: "%WinDir%",
    4: "%WinDir%//[SysWOW64|system32]",
    5: "%ProgramFiles%",
    6: "%AppData%",
    7: "%UserProfile%",
    8: "%ProgramData%|%ProgramFiles%",
}

int_to_directory = lambda x: DIRECTORY_MAPPING[x]
directory_to_int = lambda x: {v: k for (k, v) in DIRECTORY_MAPPING.items()}[x]

bytes_to_directory = lambda x: int_to_directory(cast.u8(x))
directory_to_bytes = lambda x: cast.p8(directory_to_int(x))

ascii_bytes_to_directory = lambda x: int_to_directory(cast.ascii_bytes_to_int(x))
directory_to_ascii_bytes = lambda x: cast.int_to_ascii_bytes(directory_to_int(x))


def unpack_c2(packed_c2: bytes) -> list[dict[str, typing.Any]]:
    """
    Unpacks the packed_c2 bytes and returns a list of dictionaries containing the C2 information.

    :param packed_c2: The packed C2 bytes to be unpacked.
    :return: A list of dictionaries, where each dictionary represents a C2.
    """
    results = list()
    for c2 in (x for x in packed_c2.split(C2_SEPARATOR) if x):
        host, port, tls = c2.split(b":")
        results.append(
            {"host": host.decode("utf-8"), "port": int(port), "tls": bool(int(tls))}
        )
    return results


def pack_c2(unpacked_c2: list[dict[str, typing.Any]]) -> bytes:
    """
    Packs the unpacked C2 configuration into a byte string.

    :param unpacked_c2: A list of dictionaries representing the unpacked C2 configuration.
    :return: A byte string representing the packed C2 configuration.
    """
    result = bytes()
    for x in unpacked_c2:
        result += (
            x["host"].encode()
            + b":"
            + str(x["port"]).encode()
            + b":"
            + str(int(x["tls"])).encode()
            + C2_SEPARATOR
        )
    return result


def unpack_window_names(packed_data: bytes) -> list[str]:
    """
    Unpacks the window names from the packed data.

    :param packed_data: The packed data containing window names.
    :return: A list of unpacked window names.
    """
    if not packed_data[0]:
        return list()
    return cast.utf16_to_str(packed_data).split(";")


def pack_window_names(unpacked_data: list[str]) -> bytes:
    """
    Packs a list of window names into a byte string.

    :param unpacked_data: The list of window names to be packed.
    :return: The packed window names as a byte string.
    """
    if not unpacked_data:
        return b"\x00\x00"
    return cast.str_to_utf16(";".join(unpacked_data))


CONFIGURATION_MAPPING = {
    0: ("c2_list", unpack_c2, pack_c2),
    1: ("botnet", cast.utf8_to_str, cast.str_to_utf8),
    2: ("connect_interval_in_second", cast.ascii_bytes_to_int, cast.int_to_ascii_bytes),
    3: ("enable_install_flag", cast.byte_to_bool, cast.bool_to_byte),
    4: ("enable_hkcu_run_persistence_flag", cast.byte_to_bool, cast.bool_to_byte),
    5: ("enable_hklm_run_persistence_flag", cast.byte_to_bool, cast.bool_to_byte),
    7: (
        "keylogger_maximum_file_size",
        cast.ascii_bytes_to_int,
        cast.int_to_ascii_bytes,
    ),
    8: (
        "enable_hklm_policies_explorer_run_flag",
        cast.byte_to_bool,
        cast.bool_to_byte,
    ),
    9: ("install_parent_directory", ascii_bytes_to_directory, directory_to_ascii_bytes),
    10: ("install_filename", cast.utf16_to_str, cast.str_to_utf16),
    12: (
        "enable_persistence_directory_and_binary_hidding_flag",
        cast.byte_to_bool,
        cast.bool_to_byte,
    ),
    13: (
        "enable_process_injection_flag",
        cast.ascii_bytes_to_bool,
        cast.bool_to_ascii_bytes,
    ),
    14: ("mutex", cast.utf8_to_str, cast.str_to_utf8),
    15: ("keylogger_mode", cast.ascii_bytes_to_int, cast.int_to_ascii_bytes),
    16: (
        "keylogger_parent_directory",
        ascii_bytes_to_directory,
        directory_to_ascii_bytes,
    ),
    17: ("keylogger_filename", cast.utf16_to_str, cast.str_to_utf16),
    18: (
        "enable_keylogger_file_encryption_flag",
        cast.byte_to_bool,
        cast.bool_to_byte,
    ),
    19: ("enable_keylogger_file_hidding_flag", cast.byte_to_bool, cast.bool_to_byte),
    20: ("enable_screenshot_flag", cast.byte_to_bool, cast.bool_to_byte),
    21: (
        "screenshot_interval_in_minutes",
        cast.ascii_bytes_to_int,
        cast.int_to_ascii_bytes,
    ),
    22: (
        "enable_screenshot_specific_window_names_flag",
        cast.byte_to_bool,
        cast.bool_to_byte,
    ),
    23: ("screenshot_specific_window_names", unpack_window_names, pack_window_names),
    24: (
        "screenshot_specific_window_names_interval_in_seconds",
        cast.ascii_bytes_to_int,
        cast.int_to_ascii_bytes,
    ),
    25: (
        "screenshot_parent_directory",
        ascii_bytes_to_directory,
        directory_to_ascii_bytes,
    ),
    26: ("screenshot_folder", cast.utf8_to_str, cast.str_to_utf8),
    27: ("enable_screenshot_encryption_flag", cast.byte_to_bool, cast.bool_to_byte),
    35: ("enable_audio_recording_flag", cast.byte_to_bool, cast.bool_to_byte),
    36: (
        "audio_recording_duraction_in_minutes",
        cast.ascii_bytes_to_int,
        cast.int_to_ascii_bytes,
    ),
    37: ("audio_record_parent_directory", bytes_to_directory, directory_to_bytes),
    38: ("audio_record_folder", cast.utf8_to_str, cast.str_to_utf8),
    39: ("disable_uac_flag", cast.byte_to_bool, cast.bool_to_byte),
    40: ("logging_mode", cast.ascii_bytes_to_int, cast.int_to_ascii_bytes),
    41: ("connect_delay_in_second", cast.ascii_bytes_to_int, cast.int_to_ascii_bytes),
    42: ("keylogger_specific_window_names", unpack_window_names, pack_window_names),
    43: (
        "enable_browser_cleaning_on_startup_flag",
        cast.byte_to_bool,
        cast.bool_to_byte,
    ),
    44: (
        "enable_browser_cleaning_only_for_the_first_run_flag",
        cast.byte_to_bool,
        cast.bool_to_byte,
    ),
    45: (
        "browser_cleaning_sleep_time_in_minutes",
        cast.ascii_bytes_to_int,
        cast.int_to_ascii_bytes,
    ),
    46: ("enable_uac_bypass_flag", cast.byte_to_bool, cast.bool_to_byte),
    48: ("install_directory", cast.utf16_to_str, cast.str_to_utf16),
    49: ("keylogger_root_directory", cast.utf16_to_str, cast.str_to_utf16),
    50: ("enable_watchdog_flag", cast.byte_to_bool, cast.bool_to_byte),
    52: ("license", cast.utf8_to_str, cast.str_to_utf8),
    53: (
        "enable_screenshot_mouse_drawing_flag",
        cast.byte_to_bool,
        cast.bool_to_byte,
    ),
    54: ("tls_raw_certificate", cast.bytes_to_b64_str, base64.b64decode),
    55: ("tls_key", cast.bytes_to_b64_str, base64.b64decode),
    56: ("tls_raw_peer_certificate", cast.bytes_to_b64_str, base64.b64decode),
}


def read_encrypted_configuration(path: pathlib.Path) -> bytes | None:
    """
    Read the encrypted configuration from the given file path.

    :param path: The path to the configuration file.
    :return: The encrypted configuration as bytes, or None if the file cannot be parsed or the configuration is not found.
    """
    if not (pe := lief.parse(path)):
        return None

    for first_level_child in pe.resources.childs:
        if first_level_child.id != 10:
            continue

        for second_level_child in first_level_child.childs:
            if second_level_child.name == "SETTINGS":
                return bytes(second_level_child.childs[0].content)


def patch_encrypted_configuration(
    path: pathlib.Path, encrypted_configuration: bytes
) -> None:
    """
    Patch the encrypted configuration in the specified PE file.

    :param path: The path to the PE file.
    :param encrypted_configuration: The encrypted configuration to patch the PE with.
    """
    if not (pe := lief.parse(path)):
        raise RuntimeError(f"Failed to load PE {path}")

    for first_level_child in pe.resources.childs:
        if first_level_child.id != 10:
            continue

        for second_level_child in first_level_child.childs:
            if second_level_child.name == "SETTINGS":
                second_level_child.delete_child(0)
                second_level_child.add_data_node(
                    lief.PE.ResourceData(list(encrypted_configuration), 0)
                )

                builder = lief.PE.Builder(pe)
                builder.build_resources(True)
                builder.build()
                builder.write(str(path))

                return


def decrypt_encrypted_configuration(
    encrypted_configuration: bytes,
) -> tuple[bytes, bytes]:
    """
    Decrypts the encrypted configuration.

    :param encrypted_configuration: The encrypted configuration to be decrypted.
    :return: A tuple containing the decrypted key and the decrypted configuration.
    """
    key_size = cast.u8(encrypted_configuration[:1])
    key = encrypted_configuration[1 : 1 + key_size]
    return key, ARC4.ARC4Cipher(key).decrypt(encrypted_configuration[key_size + 1 :])


def encrypt_configuration(configuration: bytes, key: bytes) -> bytes:
    """
    Encrypts the given configuration using the provided key.

    :param configuration: The configuration to be encrypted.
    :param key: The encryption key.
    :return: The encrypted configuration.
    """
    return cast.p8(len(key)) + key + ARC4.ARC4Cipher(key).encrypt(configuration)


def unpack_configuration(packed_configuration: bytes) -> dict[str, typing.Any]:
    """
    Unpacks the packed configuration and returns a dictionary.

    :param packed_configuration: The packed configuration as bytes.
    :return: A dictionary containing the unpacked configuration.
    """
    result = dict()
    for i, x in enumerate(
        (x for x in packed_configuration.split(CONFIGURATION_SEPARATOR) if x)
    ):
        if not (tmp := CONFIGURATION_MAPPING.get(i, None)):
            result[i] = cast.bytes_to_b64_str(x)
            continue

        result[tmp[0]] = tmp[1](x)

    return result


def pack_configuration(unpacked_configuration: dict[str, typing.Any]) -> bytes:
    """
    Packs the unpacked configuration into a byte string.

    :param unpacked_configuration: The unpacked configuration as a dictionary.
    :return: The packed configuration as a byte string.
    """
    results = list()

    for i, x in enumerate(unpacked_configuration.items()):
        if not (tmp := CONFIGURATION_MAPPING.get(i, None)):
            results.append(base64.b64decode(x[1]))
            continue

        results.append(tmp[2](x[1]))

    return CONFIGURATION_SEPARATOR.join(results)
